<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>IOSP Overview</title>
</head>

<body>
<h1><img src="../netcdfBig.gif" width="100" height="55">Writing an IOSP : Overview</h1>
<p>A client uses the <strong>NetcdfFile</strong>, <strong>NetcdfDataset</strong>, or one of the <strong>Scientific Dataset APIs</strong> to read data from a CDM file. These  provide a rich and sometimes complicated API to the client. Behind the scenes, when any of these APIs actually read from a dataset, however, they use a very  much simpler interface. The Netcdf Java library has many implementations of this interface, one for each different file format that it knows how to read. This design is called a <strong><em>Service Provider</em></strong> pattern; since the implementations are providing input/output, we call them <strong>I/O Service Providers</strong>, or <strong>IOSP</strong>s for short. </p>
<p><strong>IOSPs</strong> are managed by the <strong>NetcdfFile</strong> class. When a client requests a dataset (by calling <strong>NetcdfFile.open</strong>), the file is opened as a <strong>ucar.unidata.io.RandomAccessFile</strong> (an improved version of <strong>java.io.RandomAccessFile)</strong>. Each registered IOSP is then asked &quot;is this your file?&quot; by calling <strong>isValidFile</strong>( ucar.unidata.io.RandomAccessFile). The first one that returns true claims it. </p>
<h3>The <strong>ucar.nc2.IOServiceProvider</strong> interface</h3>
<pre>public interface <strong>ucar.nc2.IOServiceProvider</strong> {</pre>
<pre>  // Check if this is a valid file for this IOServiceProvider.
  public boolean <strong>isValidFile</strong>( ucar.unidata.io.RandomAccessFile raf) throws IOException;</pre>
<pre>  // Open existing file, and populate ncfile with it.
  public void <strong>open</strong>(ucar.unidata.io.RandomAccessFile raf, NetcdfFile ncfile, CancelTask cancelTask) throws IOException;</pre>
<pre>  // Read data from a top level Variable and return a memory resident Array.
  public ucar.ma2.Array <strong>readData</strong>(ucar.nc2.Variable v2, List section) throws java.io.IOException, ucar.ma2.InvalidRangeException;</pre>
<pre>  // Read data from a Variable that is nested in one or more Structures. 
  // If there are no Structures in the file, this will never be called. 
  public ucar.ma2.Array <strong>readNestedData</strong>(ucar.nc2.Variable v2, java.util.List section) throws IOException, ucar.ma2.InvalidRangeException;</pre>
<pre>  // Close the file.
  public void <strong>close</strong>() throws IOException;</pre>
<pre>  // Extend the file if needed in a way that is compatible with the current metadata.
  public boolean <strong>syncExtend</strong>() throws IOException;</pre>
<pre>  // Check if file has changed, and reread metadata if needed.
  public boolean <strong>sync</strong>() throws IOException;</pre>
<pre>  // A way to communicate arbitrary information to an iosp.
  public void <strong>setSpecial</strong>( Object special);</pre>
<pre>  // print Debug info for this object.
  public String <strong>toStringDebug</strong>(Object o);</pre>
<pre>  // Show debug / underlying implementation details 
  public String <strong>getDetailInfo</strong>();</pre>
<pre>}</pre>
<ol>
  <li>You must examine the file that is passed to you, and quickly and accurately determine if it is can be opened by this IOSP.</li>
  <li>You will then be called again with the same file, and an empty NetcdfFile object, which you will fill. If you need to do a lot of I/O, you should periodically check<strong> cancelTask.isCancel()</strong>, and if its true, return immediately. This allows users to bail out of opening a file if its taking too long. </li>
  <li>Data will be read from Variable through this call. The section list is a list of <strong>ucar.ma2.Range</strong> which define the requested data subset.</li>
  <li>If you use Structures, data for Variables that are members of Structures are read through this method.</li>
  <li>Release all resources, for example, by calling <strong>RandomAccessFile.close</strong>().</li>
  <li>If the file may change since it was opened, you may optionally implement this routine. The changes must not affect any of the structural metadata. For example, in the NetCDF-3 IOSP, we check to see if the record dimension has grown.</li>
  <li> If the file may change since it was opened, you may optionally implement this routine. The structural metadata is allowed to change. For example, in the GRIB IOSP, we check to see if new Grib records were added, and we may add or modify existing coordinate variables if they have.</li>
  <li> This allows applications to pass an arbitrary object to the IOSP, through the <strong>NetcdfFile.open( location,  buffer_size,  cancelTask,  spiObject) </strong>method. As a rule, you should not count on getting any such special information. </li>
  <li>A little-used debugging aide, return null or an empty String. </li>
  <li>Here you can pass any information that is useful to debugging. It can be viewed through the ToolsUI. </li>
</ol>
<p>&nbsp;</p>
<h3>Design goals for IOSP implementations</h3>
<ul>
  <li>
    <h4>Allow access to the dataset through the netCDF/CDM API</h4>
  </li>
  <li>
    <h4>Allow user access to every interesting bit of information in the dataset </h4>
  </li>
  <li>
    <h4>Hide details related to file format (eg links, file structure details)</h4>
  </li>
  <li>
    <h4>Try to mimic data access efficiency of netCDF-3</h4>
  </li>
  <li>
    <h4>Create good <em>use</em> <em>metadata</em>: accurate coordinate systems, enable classification by scientific data type</h4>
  </li>
  <li>
    <h4>Create good <em>discovery metadata</em> in the global attributes: title, creator, version, date created, etc. </h4>
  </li>
  <li>
    <h4>Follow standards and good practices </h4>
  </li>
</ul>
<p>&nbsp;</p>
<h2>Design issues for IOSP implementors</h2>
<ul>
  <li>
    <h3>What are the netCDF objects to expose? Should I use netCDF-3 or full netCDF4/CDM data model? Attributes vs Variables? </h3>
  </li>
  <li>
    <h3>How do I make   data access efficient? What are the common use cases? </h3>
  </li>
  <li>
    <h3>How much work should I do in the open() method? Can/should I defer some processing?</h3>
  </li>
  <li>
    <h3>Should I cache data arrays? Can I provide efficient strided access?</h3>
  </li>
  <li>
    <h3>What to do if dataset is not self contained : external tables, hardcoding? </h3>
  </li>
</ul>
<hr WIDTH="100%">
<address>
<img src="../nc.gif" width="64" height="64"> This document is maintained by John Caron and was last updated on Aug 3, 2007
</address>
<p>&nbsp; </p>
</body>
</html>
